{"version":3,"sources":["../../js-snippets/inheritObject.js"],"names":["SuperClass","property","prototype","getSuperValue","SubClass1","subproperty","getSubValue","child1","SubClass2","call","child2","SubClass3","constructor","child3","inherits","Parent","Child","F","SubClass4","child4"],"mappings":";;AAAA;;;;AAIA,IAAMA,aAAa,SAAbA,UAAa,GAAY;AAC7B,OAAKC,QAAL,GAAgB,IAAhB;AACD,CAFD;;AAIAD,WAAWE,SAAX,CAAqBC,aAArB,GAAqC,YAAY;AAC/C,SAAO,KAAKF,QAAZ;AACD,CAFD;;AAIA;AACA;AACA;AACA;AACA;;AAEA,IAAMG,YAAY,SAAZA,SAAY,GAAY;AAC5B,OAAKC,WAAL,GAAmB,KAAnB;AACD,CAFD;;AAIAD,UAAUF,SAAV,GAAqB,IAAIF,UAAJ,EAArB,C,CAAuC;;AAEvCI,UAAUF,SAAV,CAAoBI,WAApB,GAAkC,YAAY;AAC5C,SAAO,KAAKD,WAAZ;AACD,CAFD;;AAIA,IAAIE,SAAS,IAAIH,SAAJ,EAAb;;AAEA;AACA;AACA;;AAEA,IAAMI,YAAY,SAAZA,SAAY,GAAY;AAC5BR,aAAWS,IAAX,CAAgB,IAAhB,EAD4B,CACL;AACvB,OAAKJ,WAAL,GAAmB,KAAnB;AACD,CAHD;;AAKA,IAAIK,SAAS,IAAIF,SAAJ,EAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMG,YAAY,SAAZA,SAAY,GAAY;AAC5BX,aAAWS,IAAX,CAAgB,IAAhB,EAD4B,CACL;AACvB,OAAKJ,WAAL,GAAmB,KAAnB;AACD,CAHD;;AAKAM,UAAUT,SAAV,GAAsB,IAAIF,UAAJ,EAAtB,C,CAAwC;AACxCW,UAAUT,SAAV,CAAoBU,WAApB,GAAkCD,SAAlC,C,CAA6C;AAC7CA,UAAUT,SAAV,CAAoBI,WAApB,GAAkC,YAAY;AAC5C,SAAO,KAAKD,WAAZ;AACD,CAFD;;AAIA,IAAIQ,SAAS,IAAIF,SAAJ,EAAb;AACAE,OAAOP,WAAP;;AAEA;AACA;AACA;AACA,IAAMQ,WAAW,SAAXA,QAAW,CAAUC,MAAV,EAAkBC,KAAlB,EAAyB;AACxC,MAAMC,IAAI,SAAJA,CAAI,GAAY,CAAE,CAAxB;AACAA,IAAEf,SAAF,GAAca,OAAOb,SAArB;AACAc,QAAMd,SAAN,GAAkB,IAAIe,CAAJ,EAAlB,CAHwC,CAGb;AAC3BD,QAAMd,SAAN,CAAgBU,WAAhB,GAA8BI,KAA9B,CAJwC,CAIH;AACtC,CALD;;AAOA,IAAME,YAAY,SAAZA,SAAY,GAAY;AAC5BlB,aAAWS,IAAX,CAAgB,IAAhB;AACA,OAAKJ,WAAL,GAAmB,KAAnB;AACD,CAHD;;AAKAS,SAASd,UAAT,EAAqBkB,SAArB;;AAEAA,UAAUhB,SAAV,CAAoBI,WAApB,GAAkC,YAAY;AAC5C,SAAO,KAAKD,WAAZ;AACD,CAFD;;AAIA,IAAIc,SAAS,IAAID,SAAJ,EAAb","file":"inheritObject.js","sourcesContent":["/**\n * Created by leonard on 2016/11/26.\n */\n\nconst SuperClass = function () {\n  this.property = true;\n};\n\nSuperClass.prototype.getSuperValue = function () {\n  return this.property;\n};\n\n// 原型链继承\n// 主要问题:\n// 1. 假若父类有一个属性是引用类型，则所有的子类公用该属性\n// 2. 没办法在不影响所有子类对象实例的情况下，向父类的构造函数传递参数\n// 故实践中很少单独使用原型链继承\n\nconst SubClass1 = function () {\n  this.subproperty = false;\n};\n\nSubClass1.prototype= new SuperClass(); // 只能在此处向父类传递参数，会影响所有的子类\n\nSubClass1.prototype.getSubValue = function () {\n  return this.subproperty;\n};\n\nlet child1 = new SubClass1();\n\n// 借用构造函数\n// 仅解决了不能向父类的构造函数传递参数的问题，但引入了更多的问题\n// 故实践中也很少单独使用\n\nconst SubClass2 = function () {\n  SuperClass.call(this); // 可以在此处向父类构造函数传递参数\n  this.subproperty = false;\n};\n\nlet child2 = new SubClass2();\n\n// 组合继承\n// 融化了原型链继承和利用构造函数继承的方式\n// 是 JavaScript 中最常用的继承模式\n// 不过也存在一个小问题：\n// 会调用两次父类构造函数：\n// 一次是在创建子类原型的时候,还有一次是在子类构造函数的内部\n// 所以父类的属性会存在两个拷贝\n\nconst SubClass3 = function () {\n  SuperClass.call(this); // 第一次调用父类的构造函数\n  this.subproperty = false;\n};\n\nSubClass3.prototype = new SuperClass(); // 第二次调用父类的构造函数\nSubClass3.prototype.constructor = SubClass3; // 修正 constructor 指向\nSubClass3.prototype.getSubValue = function () {\n  return this.subproperty;\n};\n\nlet child3 = new SubClass3();\nchild3.getSubValue();\n\n// 寄生组合继承\n// 利用寄生的方式，不仅解决了组合继承的小问题，同时还封装了继承的操作\n// 思想：不需要再创建一个父类的原型，只需要创建一个对象，令其指向对象的原型即可\nconst inherits = function (Parent, Child) {\n  const F = function () {};\n  F.prototype = Parent.prototype;\n  Child.prototype = new F(); // 创建并指向\n  Child.prototype.constructor = Child; // 修正 constructor 指向\n};\n\nconst SubClass4 = function () {\n  SuperClass.call(this);\n  this.subproperty = false;\n};\n\ninherits(SuperClass, SubClass4);\n\nSubClass4.prototype.getSubValue = function () {\n  return this.subproperty;\n};\n\nlet child4 = new SubClass4();\n"]}